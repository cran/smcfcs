<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Jonathan Bartlett" />

<meta name="date" content="2016-01-30" />

<title>smcfcs</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">smcfcs</h1>
<h4 class="author"><em>Jonathan Bartlett</em></h4>
<h4 class="date"><em>2016-01-30</em></h4>
</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Missing data are a common issue in many fields of empirical research. An popular approach to handling missing data is the method of multiple imputation (MI). Multiple imputation involves replacing missing values by a number of imputations, creating multiple imputed datasets. Each completed dataset is then analysed as usual, and estimates and standard errors are combined across imputations using rules developed by Rubin.</p>
<p>The most popular approach to imputation uses parametric models for the missing variables given the observed. Multiple imputation gives valid inferences provided that the missing data satisfy the so called missing at random (MAR) assumption and that the imputation models used are correctly specified.</p>
<div id="joint-model-and-fcs-multiple-imputation" class="section level2">
<h2>Joint model and FCS multiple imputation</h2>
<p>When multiple variables are affected by missingness, the traditional approach to imputation is to specify a joint (or multivariate model) for the partially observed variables. One of the earliest examples of this was MI using the multivariate normal model. Rather than specifying a joint model directly, a popular alternative is the fully conditional specification (FCS), or chained equations approach. In FCS MI separate conditional models are specified for each partially observed variable. In each of these conditional models, by default all of the variables serve as predictors. For an overview of the FCS MI and an implementation of it in R, see <a href="http://www.jstatsoft.org/v45/i03/paper">van Buuren and Groothuis-Oudshoorn</a>.</p>
</div>
<div id="imputation-model-compatibility" class="section level2">
<h2>Imputation model compatibility</h2>
<p>When missing values are imputed from a misspecified model, in general invalid inferences will result. One way in which misspecification can occur is when the imputation and substantive (analysis) model of interest are incompatible. Loosely speaking, this means there exists no joint model which contains the imputation model and the substantive model as the corresponding conditionals. In this case, as described by <a href="http://doi.org/10.1177/0962280214521348">Bartlett <em>et al</em> (2014)</a>, assuming that the substantive model is correctly specified, unless the imputation and substantive models can be made compatible by imposing a restriction on the imputation model, incompatiblity implies the imputation model is misspecified.</p>
<p>Such incompatibility between the imputation model used to impute a partially observed covariate and the substantive/outcome model can arise for example when the latter includes interactions or non-linear effects of variables. A further example is when the substantive model is a Cox proportional hazards model for a censored time to event outcome. In these cases, it may be difficult or impossible to specify an imputation model for a covariate which is compatible with the model for the outcome (the substantive model) using standard imputation models as available in existing packages.</p>
</div>
</div>
<div id="substantive-model-compatible-fully-conditional-specification-multiple-imputation" class="section level1">
<h1>Substantive Model Compatible Fully Conditional Specification multiple imputation</h1>
<p>The substantive model compatible modification of FCS MI (SMC-FCS), proposed by <a href="http://doi.org/10.1177/0962280214521348">Bartlett <em>et al</em> (2014)</a>, ensures that each partially observed variable is imputed from an imputation model which is compatible with a user specified model for the outcome (which is typically the substantive model of interest, although see below regarding auxiliary variables). As described in further detail in the linked paper, for each partially observed variable, e.g. <code>x1</code>, in SMC-FCS a model is specified for the conditional distribution of <code>x1</code> given the other partially observed variables <code>x2,x3,..,xp</code> and fully observed covariates <code>z</code>. This, together with the specified substantive model (a model for the outcome <code>y</code>) defines an imputation model for <code>x1</code> which is guaranteed to be compatible with this specified substantive model.</p>
<div id="sampling-from-the-imputation-distribution" class="section level2">
<h2>Sampling from the imputation distribution</h2>
<p>Unfortunately, the resulting imputation model for each partially observed variable generally does not belong to a standard parametric family, complicating the imputation of missing values. To overcome this, <code>smcfcs</code> uses the method of rejection sampling, which is more computationally intensive than direct sampling methods.</p>
</div>
<div id="statistical-properties" class="section level2">
<h2>Statistical properties</h2>
<p>SMC-FCS ensures compatibility between each partially observed covariate’s imputation model with the substantive model. However, when there is more than one partially observed variable, it does not guarantee that the corresponding different imputation models are mutually compatible. Consequently, as described further by <a href="http://doi.org/10.1177/0962280214521348">Bartlett <em>et al</em> (2014)</a>, only in special cases does SMC-FCS generate imputations from a well defined Bayesian joint model. Nonetheless, by ensuring compatibility between each partially observed variable’s imputation model and the substantive model, it arguably overcomes (compared to standard FCS MI) the type of model incompatibility which is most likely to adversely affect inferences.</p>
</div>
<div id="when-smc-fcs-may-be-preferable-to-fcsmice" class="section level2">
<h2>When SMC-FCS may be preferable to FCS/MICE</h2>
<p>In certain situations it may be advantageous to use SMC-FCS rather than traditional FCS MI. Important examples, as mentioned previously, include situations where the substantive (outcome) model includes interactions or non-linear effects of some of the covariates, or where the outcome model is itself non-linear, such as a Cox proportional hazards model. See <a href="http://doi.org/10.1177/0962280214521348">Bartlett <em>et al</em> (2014)</a> for simulation results comparing the two approaches in these situations.</p>
</div>
</div>
<div id="the-smcfcs-package" class="section level1">
<h1>The <code>smcfcs</code> package</h1>
<p>The <code>smcfcs</code> function in the <code>smcfcs</code> package implements the SMC-FCS procedure. Currently linear, logistic and Cox proportional hazards substantive models. Competing risks outcome data can also be accommodated, with a Cox proportional hazards model used to model each cause specific hazard function. Partially observed variables can be imputed using normal linear regression, logistic regression (for binary variables), proportional odds regression (sometimes known as ordinal logistic regression, suitable for ordered categorical variables), multinomial logistic regression (for unordered categorical variables), and Poisson regression (for count variables). In the following we describe some of the important aspects of using <code>smcfcs</code> by way of an example data frame.</p>
<div id="example---linear-regression-substantive-model-with-quadratic-covariate-effects" class="section level2">
<h2>Example - linear regression substantive model with quadratic covariate effects</h2>
<p>To illustrate the package, we use the simple example data frame <code>ex_linquad</code>, which is included with the package. This data frame was simulated for <code>n=1000</code> independent rows. For each row, variables <code>y,x,z,v</code> were intended to be collected, but there are missing values in <code>x</code>. The values have been made artifically missing, with the probability of missingness dependent on (the fully observed) <code>y</code> variable. Below the first 10 rows of the data frame are shown:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(smcfcs)
ex_linquad[<span class="dv">1</span>:<span class="dv">10</span>,]</code></pre></div>
<pre><code>##             y          z          x        xsq           v
## 1  -0.3404639 -1.2053334 -1.2070657 1.45700772 -2.18088437
## 2   2.1699185  0.3014667  0.2774292 0.07696698  0.17779805
## 3   2.0293128 -1.5391452  1.0844412 1.17601267  0.97370618
## 4   6.6311247  0.6353707 -2.3456977 5.50229771 -1.15350311
## 5   3.9096291  0.7029518  0.4291247 0.18414800 -1.22676124
## 6  -0.5019313 -1.9058829         NA         NA -0.53958740
## 7   0.5816303  0.9389214         NA         NA -2.31497909
## 8   1.0236009 -0.2244921         NA         NA -0.03351108
## 9  -1.2942170 -0.6738168         NA         NA -1.01040885
## 10  1.9041271  0.4457874 -0.8900378 0.79216734 -2.72923160</code></pre>
<p>As shown, the <code>xsq</code> variable is equal to the square of the <code>x</code> variable. Since the latter has missing values, so does the former. We now impute the missing values in <code>x</code> and <code>xsq</code>, compatibly with a substantive model for the outcome <code>y</code> which is specified as a linear regression, with <code>z</code>, <code>x</code> and <code>xsq</code> as covariates:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123</span>)
<span class="co">#impute missing values in x, compatibly with quadratic substantive model</span>
imps &lt;-<span class="st"> </span><span class="kw">smcfcs</span>(ex_linquad, <span class="dt">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="dt">smformula=</span><span class="st">&quot;y~z+x+xsq&quot;</span>,<span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>))</code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<p>As demonstrated here, the minimal arguments to pass to <code>smcfcs</code> are the data frame to be used, the substantive model type, the substantive model formula, and a method vector. The substantive model type specifies whether the model for the outcome is linear, logistic or Cox regression, or a competing risks analysis (see documentation). The <code>smformula</code> specifies the linear predictor of the substantive/outcome model. Here we specified that the outcome <code>y</code> is assumed to follow a linear regression model, with <code>z</code>, <code>x</code> and <code>xsq</code> as predictors.</p>
<p>Lastly, we passed a vector of strings as the <code>method</code> argument. This specifies, for each column in the data frame, the method to use for imputation. As in the example, empty strings should be passed for those columns which are fully observed and thus are not to be imputed. For <code>x</code> we specify <code>norm</code>, in order to impute using a normal linear regression model. See the help for <code>smcfcs</code> for the syntax for other imputation model types. For <code>xsq</code> we specify <code>&quot;x^2&quot;</code> as the imputation method. This instructs <code>smcfcs</code> to impute <code>xsq</code> by simply squaring the imputed values of <code>x</code>. Such a specification could also be used with the <code>mice</code> package, which implements standard FCS MI. Note however that here, through specifying the substantive model as including an effect of <code>xsq</code>, <code>smcfcs</code> is imputing the missing values in <code>x</code> which allows for a quadratic effect on <code>y</code>.</p>
<p>Having generated the imputed datasets, we can now fit our substantive model of interest. Here we make use of the <code>mitools</code> package to fit our substantive model to each imputed dataset, collect the results, and combine them using Rubin’s rules:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># fit substantive model</span>
<span class="kw">library</span>(mitools)
impobj &lt;-<span class="st"> </span><span class="kw">imputationList</span>(imps$impDatasets)
models &lt;-<span class="st"> </span><span class="kw">with</span>(impobj, <span class="kw">lm</span>(y~z+x+xsq))
<span class="kw">summary</span>(<span class="kw">MIcombine</span>(models))</code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower   upper) missInfo
## (Intercept) 0.9314374 0.04305428 0.8462533 1.016621     19 %
## z           1.0115451 0.03786833 0.9358488 1.087241     28 %
## x           0.9845177 0.03353937 0.9184628 1.050573     13 %
## xsq         1.0376067 0.02235589 0.9936738 1.081540     10 %</code></pre>
<p>Here the data were simulated such that the coefficients of <code>z</code>, <code>x</code> and <code>xsq</code> are all 1. The estimates we have obtained are (reassuringly) close to these true parameter values. To illustrate the dangers of imputing a covariate using an imputation model which is not compatible with the substantive model, we now re-impute <code>x</code>, but this time imputing compatibly with a model for <code>y</code> which does not allow for the quadratic effect:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#impute missing values in x, compatibly with model for y which omits the quadratic effect</span>
imps &lt;-<span class="st"> </span><span class="kw">smcfcs</span>(ex_linquad, <span class="dt">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="dt">smformula=</span><span class="st">&quot;y~z+x&quot;</span>,<span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>))</code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<pre><code>## Warning in smcfcs(ex_linquad, smtype = &quot;lm&quot;, smformula = &quot;y~z+x&quot;, method
## = c(&quot;&quot;, : Rejection sampling failed 3 times (across all variables,
## iterations, and imputations). You may want to increase the rejection
## sampling limit.</code></pre>
<p><code>smcfcs</code> has issued some warnings about rejection sampling. We discuss this later in this vignette, but here we will continue and proceed to fit a model for <code>y</code> which includes both <code>x</code> and <code>xsq</code> (plus <code>z</code>) as covariates:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># fit substantive model</span>
impobj &lt;-<span class="st"> </span><span class="kw">imputationList</span>(imps$impDatasets)
models &lt;-<span class="st"> </span><span class="kw">with</span>(impobj, <span class="kw">lm</span>(y~z+x+xsq))
<span class="kw">summary</span>(<span class="kw">MIcombine</span>(models))</code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower    upper) missInfo
## (Intercept) 1.2645626 0.08024052 1.0969123 1.4322128     50 %
## z           1.0802626 0.06175214 0.9538006 1.2067245     42 %
## x           0.9579516 0.11692247 0.6623973 1.2535059     90 %
## xsq         0.6041747 0.06339612 0.4484521 0.7598972     86 %</code></pre>
<p>Now we have an estimate of the coefficient of <code>xsq</code> of 0.60, which is considerably smaller than the true value 1 used to simulate the data. This bias is due to the imputation model we have just used for <code>x</code> being misspecified. In particular, it was misspecified due to the fact it wrongly assumed a linear dependence of <code>y</code> on <code>x</code>, rather than allowing a quadratic dependence.</p>
</div>
<div id="imputing-using-auxiliary-variables-with-smcfcs" class="section level2">
<h2>Imputing using auxiliary variables with <code>smcfcs</code></h2>
<p>One of the strengths of multiple imputation in general is the possibility to use variables in imputation models which are subsequently not involved in the substantive model. This may be useful in order to condition or adjust for variables which are predictive of missingness, but which are not used in the substantive model of interest. Moreover, adjusting for auxiliary variables which are strongly correlated with one or more variables which are being imputed improves efficiency.</p>
<p>When using <code>smcfcs</code> to impute missing covariates, auxiliary variables <code>v</code> can be included by adding them as an additional covariate in the substantive model, as passed using the <code>smformula</code> argument. Here we are imputing <code>x</code> compatibly with a certain specification of model for the outcome. Our substantive model of interest is then a simpler model which omits <code>v</code>. For example, in the quadratic example dataset, we can add the auxiliary variable <code>v</code> using:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#impute, including v as a covariate in the substantive/outcome model</span>
imps &lt;-<span class="st"> </span><span class="kw">smcfcs</span>(ex_linquad, <span class="dt">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="dt">smformula=</span><span class="st">&quot;y~z+x+xsq+v&quot;</span>,<span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>))</code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z,v&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z,v  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<pre><code>## Warning in smcfcs(ex_linquad, smtype = &quot;lm&quot;, smformula = &quot;y~z+x+xsq+v&quot;, :
## Rejection sampling failed 1 times (across all variables, iterations, and
## imputations). You may want to increase the rejection sampling limit.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># fit substantive model, which omits v</span>
impobj &lt;-<span class="st"> </span><span class="kw">imputationList</span>(imps$impDatasets)
models &lt;-<span class="st"> </span><span class="kw">with</span>(impobj, <span class="kw">lm</span>(y~z+x+xsq))
<span class="kw">summary</span>(<span class="kw">MIcombine</span>(models))</code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower   upper) missInfo
## (Intercept) 0.9289935 0.04445245 0.8403230 1.017664     26 %
## z           1.0164477 0.03420426 0.9492172 1.083678     10 %
## x           0.9828459 0.03805117 0.9058054 1.059886     36 %
## xsq         1.0367009 0.02272418 0.9919379 1.081464     14 %</code></pre>
<p>For outcome models other than linear regression, this approach is not entirely justifiable due to the lack of collapsibility of non-linear models. For example, if a Cox model is assumed for a failure time given variables <code>x</code> and <code>v</code>, the hazard function given only <code>x</code> (i.e. omitting <code>v</code> from the model) is no longer a Cox model. Further research is warranted to explore how this might affect the resulting inferences.</p>
<p>It is also possible to include the auxiliary variable <code>v</code> without adding it to the outcome model (as given in the <code>smformula</code> argument), through specification of the <code>predictorMatrix</code> argument. Doing so conditions on <code>v</code>, but assumes that the outcome is independent of <code>v</code>, conditional on whatever covariates are specified in <code>smformula</code>. This should thus only be used when the latter assumption is justified. When it is, inferences will in general be more efficient. To make this assumption when imputing <code>x</code> in the <code>ex_linquad</code> data, we define a <code>predictorMatrix</code> which will specify that <code>x</code> be imputed using both <code>z</code> and <code>v</code>, but we omit <code>v</code> from the <code>smformula</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predMatrix &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(<span class="kw">ncol</span>(ex_linquad),<span class="kw">ncol</span>(ex_linquad)))
predMatrix[<span class="dv">3</span>,] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)
imps &lt;-<span class="st"> </span><span class="kw">smcfcs</span>(ex_linquad, <span class="dt">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="dt">smformula=</span><span class="st">&quot;y~z+x+xsq&quot;</span>,<span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>),<span class="dt">predictorMatrix=</span>predMatrix)</code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z,v  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">impobj &lt;-<span class="st"> </span><span class="kw">imputationList</span>(imps$impDatasets)
models &lt;-<span class="st"> </span><span class="kw">with</span>(impobj, <span class="kw">lm</span>(y~z+x+xsq))
<span class="kw">summary</span>(<span class="kw">MIcombine</span>(models))</code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower   upper) missInfo
## (Intercept) 0.9338025 0.04229439 0.8500233 1.017582     20 %
## z           1.0234987 0.03747970 0.9484144 1.098583     29 %
## x           1.0003323 0.03169826 0.9381710 1.062494      4 %
## xsq         1.0412116 0.02324259 0.9951710 1.087252     20 %</code></pre>
</div>
<div id="rejection-sampling-warnings" class="section level2">
<h2>Rejection sampling warnings</h2>
<p>Sometimes when running <code>smcfcs</code> you may receive warnings that the rejection sampling that <code>smcfcs</code> uses has failed to draw from the required distribution on a couple of occasions. Upon receiving this warning, it is generally good idea to re-run <code>smcfcs</code>, specifying a value for <code>rjlimit</code> which is larger than the default, until the warning is no longer issued. Having said that, when only a small number of warnings are issued, it may be fine to ignore the warnings, especially when the dataset is large.</p>
</div>
<div id="assessing-convergence" class="section level2">
<h2>Assessing convergence</h2>
<p>Like standard chained equations or FCS imputation, the SMC-FCS algorithm must be run for a sufficient number of iterations for the process to converge to its stationary distribution. The default number of iterations used is 10, but this may not be sufficient in any given dataset and model specifcication. To assess convergence, the object returned by <code>smcfcs</code> includes an object called <code>smCoefIter</code>. This matrix contains the parameter estimates of the substantive model, and is indexed by imputation number, parameter number, and iteration number. To assess convergence, one can call smcfcs with <code>m=1</code> and <code>numit</code> suitably chosen (e.g. <code>numit=100</code>). The values in the resulting smCoefIter matrix can then be plotted to assess convergence. To illustrate, we re-run the imputation model used previously with the example data, but asking for only <code>m=1</code> imputation to be generated, and with 100 iterations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># impute once with a larger number of iterations than the default 10</span>
imps &lt;-<span class="st"> </span><span class="kw">smcfcs</span>(ex_linquad, <span class="dt">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="dt">smformula=</span><span class="st">&quot;y~z+x+xsq&quot;</span>,<span class="dt">method=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>),<span class="dt">predictorMatrix=</span>predMatrix,<span class="dt">m=</span><span class="dv">1</span>,<span class="dt">numit=</span><span class="dv">100</span>)</code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z,v  plus outcome&quot;</code></pre>
<pre><code>## Warning in smcfcs(ex_linquad, smtype = &quot;lm&quot;, smformula = &quot;y~z+x+xsq&quot;,
## method = c(&quot;&quot;, : Rejection sampling failed 4 times (across all variables,
## iterations, and imputations). You may want to increase the rejection
## sampling limit.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># plot estimates of the fourth parameter of the substantive model against iteration number</span>
<span class="kw">plot</span>(imps$smCoefIter[<span class="dv">1</span>,<span class="dv">4</span>,])</code></pre></div>
<p><img src="data:image/png;base64,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" /></p>
<p>The plot shows that the process appears to converge rapidly, such that the default choice of <code>numit=10</code> is probably fine here. Of course we should also examine the corresponding plots for the other parameters of the substantive model, since convergence may require more than 10 iterations for some of these.</p>
<h2 id="references">
References
</h3>
<p>Bartlett JW, Seaman SR, White IR, Carpenter JR. Multiple imputation of covariates by fully conditional specification: accommodating the substantive model. <a href="http://doi.org/10.1177/0962280214521348">Statistical Methods in Medical Research</a>, 2015; 24(4):462-487</p>
<p>van Buuren S, Groothuis-Oudshoorn K. mice: Multivariate Imputation by Chained Equations in R. <a href="http://www.jstatsoft.org/v45/i03/paper">Journal of Statistical Software</a>, 2011; 45(3)</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
