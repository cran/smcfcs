<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Jonathan Bartlett" />

<meta name="date" content="2022-11-07" />

<title>smcfcs</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">smcfcs</h1>
<h4 class="author">Jonathan Bartlett</h4>
<h4 class="date">2022-11-07</h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Missing data are a common issue in many fields of empirical research.
An popular approach to handling missing data is the method of multiple
imputation (MI). Multiple imputation involves replacing missing values
by a number of imputations, creating multiple imputed datasets. Each
completed dataset is then analysed as usual, and estimates and standard
errors are combined across imputations using rules developed by
Rubin.</p>
<p>The most popular approach to imputation uses parametric models for
the missing variables given the observed. Multiple imputation gives
valid inferences provided that the missing data satisfy the so called
missing at random (MAR) assumption and that the imputation models used
are correctly specified.</p>
<div id="joint-model-and-fcs-multiple-imputation" class="section level2">
<h2>Joint model and FCS multiple imputation</h2>
<p>When multiple variables are affected by missingness, the traditional
approach to imputation is to specify a joint (or multivariate model) for
the partially observed variables. One of the earliest examples of this
was MI using the multivariate normal model. Rather than specifying a
joint model directly, a popular alternative is the fully conditional
specification (FCS), or chained equations approach. In FCS MI separate
conditional models are specified for each partially observed variable.
In each of these conditional models, by default all of the variables
serve as predictors. For an overview of the FCS MI and an implementation
of it in R, see <a href="https://doi.org/10.18637/jss.v045.i03">van
Buuren and Groothuis-Oudshoorn</a>.</p>
</div>
<div id="imputation-model-compatibility" class="section level2">
<h2>Imputation model compatibility</h2>
<p>When missing values are imputed from a misspecified model, in general
invalid inferences will result. One way in which misspecification can
occur is when the imputation and substantive (analysis) model of
interest are incompatible. Loosely speaking, this means there exists no
joint model which contains the imputation model and the substantive
model as the corresponding conditionals. In this case, as described by
<a href="https://doi.org/10.1177/0962280214521348">Bartlett <em>et
al</em> (2015)</a>, assuming that the substantive model is correctly
specified, unless the imputation and substantive models can be made
compatible by imposing a restriction on the imputation model,
incompatibility implies the imputation model is misspecified.</p>
<p>Such incompatibility between the imputation model used to impute a
partially observed covariate and the substantive/outcome model can arise
for example when the latter includes interactions or non-linear effects
of variables. A further example is when the substantive model is a Cox
proportional hazards model for a censored time to event outcome. In
these cases, it may be difficult or impossible to specify an imputation
model for a covariate which is compatible with the model for the outcome
(the substantive model) using standard imputation models as available in
existing packages.</p>
</div>
</div>
<div id="substantive-model-compatible-fully-conditional-specification-multiple-imputation" class="section level1">
<h1>Substantive Model Compatible Fully Conditional Specification
multiple imputation</h1>
<p>The substantive model compatible modification of FCS MI (SMC-FCS),
proposed by <a href="https://doi.org/10.1177/0962280214521348">Bartlett
<em>et al</em> (2015)</a>, ensures that each partially observed variable
is imputed from an imputation model which is compatible with a user
specified model for the outcome (which is typically the substantive
model of interest, although see below regarding auxiliary variables). As
described in further detail in the linked paper, for each partially
observed variable, e.g. <code>x1</code>, in SMC-FCS a model is specified
for the conditional distribution of <code>x1</code> given the other
partially observed variables <code>x2,x3,..,xp</code> and fully observed
covariates <code>z</code>. This, together with the specified substantive
model (a model for the outcome <code>y</code>) defines an imputation
model for <code>x1</code> which is guaranteed to be compatible with this
specified substantive model.</p>
<div id="sampling-from-the-imputation-distribution" class="section level2">
<h2>Sampling from the imputation distribution</h2>
<p>Unfortunately, the resulting imputation model for each partially
observed variable generally does not belong to a standard parametric
family, complicating the imputation of missing values. To overcome this,
<code>smcfcs</code> uses the method of rejection sampling, which is more
computationally intensive than direct sampling methods.</p>
</div>
<div id="statistical-properties" class="section level2">
<h2>Statistical properties</h2>
<p>SMC-FCS ensures compatibility between each partially observed
covariate’s imputation model with the substantive model. However, when
there is more than one partially observed variable, it does not
guarantee that the corresponding different imputation models are
mutually compatible. Consequently, as described further by
<a href="https://doi.org/10.1177/0962280214521348">Bartlett <em>et
al</em> (2015)</a>, only in special cases does SMC-FCS generate
imputations from a well defined Bayesian joint model. Nonetheless, by
ensuring compatibility between each partially observed variable’s
imputation model and the substantive model, it arguably overcomes
(compared to standard FCS MI) the type of model incompatibility which is
most likely to adversely affect inferences.</p>
</div>
<div id="when-smc-fcs-may-be-preferable-to-fcsmice" class="section level2">
<h2>When SMC-FCS may be preferable to FCS/MICE</h2>
<p>In certain situations it may be advantageous to use SMC-FCS rather
than traditional FCS MI. Important examples, as mentioned previously,
include situations where the substantive (outcome) model includes
interactions or non-linear effects of some of the covariates, or where
the outcome model is itself non-linear, such as a Cox proportional
hazards model. See
<a href="https://doi.org/10.1177/0962280214521348">Bartlett <em>et
al</em> (2015)</a> for simulation results comparing the two approaches
in these situations.</p>
</div>
</div>
<div id="the-smcfcs-package" class="section level1">
<h1>The <code>smcfcs</code> package</h1>
<p>The <code>smcfcs</code> function in the <code>smcfcs</code> package
implements the SMC-FCS procedure. Currently linear, logistic and Cox
proportional hazards substantive models. Competing risks outcome data
can also be accommodated, with a Cox proportional hazards model used to
model each cause specific hazard function. Partially observed variables
can be imputed using normal linear regression, logistic regression (for
binary variables), proportional odds regression (sometimes known as
ordinal logistic regression, suitable for ordered categorical
variables), multinomial logistic regression (for unordered categorical
variables), and Poisson regression (for count variables). In the
following we describe some of the important aspects of using
<code>smcfcs</code> by way of an example data frame.</p>
<div id="example---linear-regression-substantive-model-with-quadratic-covariate-effects" class="section level2">
<h2>Example - linear regression substantive model with quadratic
covariate effects</h2>
<p>To illustrate the package, we use the simple example data frame
<code>ex_linquad</code>, which is included with the package. This data
frame was simulated for <code>n=1000</code> independent rows. For each
row, variables <code>y,x,z,v</code> were intended to be collected, but
there are missing values in <code>x</code>. The values have been made
artificially missing, with the probability of missingness dependent on
(the fully observed) <code>y</code> variable. Below the first 10 rows of
the data frame are shown:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(smcfcs)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ex_linquad[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,]</span></code></pre></div>
<pre><code>##             y          z          x        xsq           v
## 1  -0.3404639 -1.2053334 -1.2070657 1.45700772 -2.18088437
## 2   2.1699185  0.3014667  0.2774292 0.07696698  0.17779805
## 3   2.0293128 -1.5391452  1.0844412 1.17601267  0.97370618
## 4   6.6311247  0.6353707 -2.3456977 5.50229771 -1.15350311
## 5   3.9096291  0.7029518  0.4291247 0.18414800 -1.22676124
## 6  -0.5019313 -1.9058829         NA         NA -0.53958740
## 7   0.5816303  0.9389214         NA         NA -2.31497909
## 8   1.0236009 -0.2244921         NA         NA -0.03351108
## 9  -1.2942170 -0.6738168         NA         NA -1.01040885
## 10  1.9041271  0.4457874 -0.8900378 0.79216734 -2.72923160</code></pre>
<p>As shown, the <code>xsq</code> variable is equal to the square of the
<code>x</code> variable. Since the latter has missing values, so does
the former. We now impute the missing values in <code>x</code> and
<code>xsq</code>, compatibly with a substantive model for the outcome
<code>y</code> which is specified as a linear regression, with
<code>z</code>, <code>x</code> and <code>xsq</code> as covariates:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#impute missing values in x, compatibly with quadratic substantive model</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>imps <span class="ot">&lt;-</span> <span class="fu">smcfcs</span>(ex_linquad, <span class="at">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="at">smformula=</span><span class="st">&quot;y~z+x+xsq&quot;</span>,<span class="at">method=</span><span class="fu">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<p>As demonstrated here, the minimal arguments to pass to
<code>smcfcs</code> are the data frame to be used, the substantive model
type, the substantive model formula, and a method vector. The
substantive model type specifies whether the model for the outcome is
linear, logistic or Cox regression, or a competing risks analysis (see
documentation). The <code>smformula</code> specifies the linear
predictor of the substantive/outcome model. Here we specified that the
outcome <code>y</code> is assumed to follow a linear regression model,
with <code>z</code>, <code>x</code> and <code>xsq</code> as
predictors.</p>
<p>Lastly, we passed a vector of strings as the <code>method</code>
argument. This specifies, for each column in the data frame, the method
to use for imputation. As in the example, empty strings should be passed
for those columns which are fully observed and thus are not to be
imputed. For <code>x</code> we specify <code>norm</code>, in order to
impute using a normal linear regression model. See the help for
<code>smcfcs</code> for the syntax for other imputation model types. For
<code>xsq</code> we specify <code>&quot;x^2&quot;</code> as the imputation method.
This instructs <code>smcfcs</code> to impute <code>xsq</code> by simply
squaring the imputed values of <code>x</code>. Such a specification
could also be used with the <code>mice</code> package, which implements
standard FCS MI. Note however that here, through specifying the
substantive model as including an effect of <code>xsq</code>,
<code>smcfcs</code> is imputing the missing values in <code>x</code>
which allows for a quadratic effect on <code>y</code>.</p>
<p>Having generated the imputed datasets, we can now fit our substantive
model of interest. Here we make use of the <code>mitools</code> package
to fit our substantive model to each imputed dataset, collect the
results, and combine them using Rubin’s rules:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit substantive model</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mitools)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>impobj <span class="ot">&lt;-</span> <span class="fu">imputationList</span>(imps<span class="sc">$</span>impDatasets)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">with</span>(impobj, <span class="fu">lm</span>(y<span class="sc">~</span>z<span class="sc">+</span>x<span class="sc">+</span>xsq))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">MIcombine</span>(models))</span></code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower   upper) missInfo
## (Intercept) 0.9334715 0.04630014 0.8403438 1.026599     32 %
## z           1.0052498 0.03733622 0.9308187 1.079681     26 %
## x           0.9849376 0.03375213 0.9183668 1.051508     15 %
## xsq         1.0387792 0.02430037 0.9902690 1.087289     27 %</code></pre>
<p>Here the data were simulated such that the coefficients of
<code>z</code>, <code>x</code> and <code>xsq</code> are all 1. The
estimates we have obtained are (reassuringly) close to these true
parameter values. To illustrate the dangers of imputing a covariate
using an imputation model which is not compatible with the substantive
model, we now re-impute <code>x</code>, but this time imputing
compatibly with a model for <code>y</code> which does not allow for the
quadratic effect:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#impute missing values in x, compatibly with model for y which omits the quadratic effect</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>imps <span class="ot">&lt;-</span> <span class="fu">smcfcs</span>(ex_linquad, <span class="at">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="at">smformula=</span><span class="st">&quot;y~z+x&quot;</span>,<span class="at">method=</span><span class="fu">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<pre><code>## Warning in smcfcs.core(originaldata, smtype, smformula, method,
## predictorMatrix, : Rejection sampling failed 3 times (across all variables,
## iterations, and imputations). You may want to increase the rejection sampling
## limit.</code></pre>
<p><code>smcfcs</code> has issued some warnings about rejection
sampling. We discuss this later in this vignette, but here we will
continue and proceed to fit a model for <code>y</code> which includes
both <code>x</code> and <code>xsq</code> (plus <code>z</code>) as
covariates:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit substantive model</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>impobj <span class="ot">&lt;-</span> <span class="fu">imputationList</span>(imps<span class="sc">$</span>impDatasets)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">with</span>(impobj, <span class="fu">lm</span>(y<span class="sc">~</span>z<span class="sc">+</span>x<span class="sc">+</span>xsq))</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">MIcombine</span>(models))</span></code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower    upper) missInfo
## (Intercept) 1.2518297 0.07721520 1.0926282 1.4110313     45 %
## z           1.0923872 0.05635147 0.9799551 1.2048193     26 %
## x           0.9277074 0.06518336 0.7859114 1.0695035     63 %
## xsq         0.6093138 0.05299860 0.4845629 0.7340648     80 %</code></pre>
<p>Now we have an estimate of the coefficient of <code>xsq</code> of
0.60, which is considerably smaller than the true value 1 used to
simulate the data. This bias is due to the imputation model we have just
used for <code>x</code> being misspecified. In particular, it was
misspecified due to the fact it wrongly assumed a linear dependence of
<code>y</code> on <code>x</code>, rather than allowing a quadratic
dependence.</p>
</div>
<div id="imputing-using-auxiliary-variables-with-smcfcs" class="section level2">
<h2>Imputing using auxiliary variables with <code>smcfcs</code></h2>
<p>One of the strengths of multiple imputation in general is the
possibility to use variables in imputation models which are subsequently
not involved in the substantive model. This may be useful in order to
condition or adjust for variables which are predictive of missingness,
but which are not used in the substantive model of interest. Moreover,
adjusting for auxiliary variables which are strongly correlated with one
or more variables which are being imputed improves efficiency.</p>
<p>When using <code>smcfcs</code> to impute missing covariates,
auxiliary variables <code>v</code> can be included by adding them as an
additional covariate in the substantive model, as passed using the
<code>smformula</code> argument. Here we are imputing <code>x</code>
compatibly with a certain specification of model for the outcome. Our
substantive model of interest is then a simpler model which omits
<code>v</code>. For example, in the quadratic example dataset, we can
add the auxiliary variable <code>v</code> using:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#impute, including v as a covariate in the substantive/outcome model</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>imps <span class="ot">&lt;-</span> <span class="fu">smcfcs</span>(ex_linquad, <span class="at">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="at">smformula=</span><span class="st">&quot;y~z+x+xsq+v&quot;</span>,<span class="at">method=</span><span class="fu">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z,v&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z,v  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<pre><code>## Warning in smcfcs.core(originaldata, smtype, smformula, method,
## predictorMatrix, : Rejection sampling failed 1 times (across all variables,
## iterations, and imputations). You may want to increase the rejection sampling
## limit.</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit substantive model, which omits v</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>impobj <span class="ot">&lt;-</span> <span class="fu">imputationList</span>(imps<span class="sc">$</span>impDatasets)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">with</span>(impobj, <span class="fu">lm</span>(y<span class="sc">~</span>z<span class="sc">+</span>x<span class="sc">+</span>xsq))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">MIcombine</span>(models))</span></code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower   upper) missInfo
## (Intercept) 0.9295283 0.04234163 0.8457342 1.013322     19 %
## z           1.0209851 0.03536731 0.9511068 1.090863     17 %
## x           0.9762357 0.03556863 0.9054434 1.047028     24 %
## xsq         1.0403799 0.02367377 0.9933561 1.087404     23 %</code></pre>
<p>For outcome models other than linear regression, this approach is not
entirely justifiable due to the lack of collapsibility of non-linear
models. For example, if a Cox model is assumed for a failure time given
variables <code>x</code> and <code>v</code>, the hazard function given
only <code>x</code> (i.e. omitting <code>v</code> from the model) is no
longer a Cox model. Further research is warranted to explore how this
might affect the resulting inferences.</p>
<p>It is also possible to include the auxiliary variable <code>v</code>
without adding it to the outcome model (as given in the
<code>smformula</code> argument), through specification of the
<code>predictorMatrix</code> argument. Doing so conditions on
<code>v</code>, but assumes that the outcome is independent of
<code>v</code>, conditional on whatever covariates are specified in
<code>smformula</code>. This should thus only be used when the latter
assumption is justified. When it is, inferences will in general be more
efficient. To make this assumption when imputing <code>x</code> in the
<code>ex_linquad</code> data, we define a <code>predictorMatrix</code>
which will specify that <code>x</code> be imputed using both
<code>z</code> and <code>v</code>, but we omit <code>v</code> from the
<code>smformula</code> argument:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>predMatrix <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim=</span><span class="fu">c</span>(<span class="fu">ncol</span>(ex_linquad),<span class="fu">ncol</span>(ex_linquad)))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>predMatrix[<span class="dv">3</span>,] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>imps <span class="ot">&lt;-</span> <span class="fu">smcfcs</span>(ex_linquad, <span class="at">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="at">smformula=</span><span class="st">&quot;y~z+x+xsq&quot;</span>,<span class="at">method=</span><span class="fu">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>),<span class="at">predictorMatrix=</span>predMatrix)</span></code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z,v  plus outcome&quot;
## [1] &quot;Imputation  2&quot;
## [1] &quot;Imputation  3&quot;
## [1] &quot;Imputation  4&quot;
## [1] &quot;Imputation  5&quot;</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>impobj <span class="ot">&lt;-</span> <span class="fu">imputationList</span>(imps<span class="sc">$</span>impDatasets)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">with</span>(impobj, <span class="fu">lm</span>(y<span class="sc">~</span>z<span class="sc">+</span>x<span class="sc">+</span>xsq))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">MIcombine</span>(models))</span></code></pre></div>
<pre><code>## Multiple imputation results:
##       with(impobj, lm(y ~ z + x + xsq))
##       MIcombine.default(models)
##               results         se    (lower   upper) missInfo
## (Intercept) 0.9335536 0.04695924 0.8384797 1.028628     36 %
## z           1.0140131 0.03476990 0.9455146 1.082512     14 %
## x           0.9866993 0.03979143 0.9051913 1.068207     42 %
## xsq         1.0393844 0.02260472 0.9949177 1.083851     12 %</code></pre>
</div>
<div id="rejection-sampling-warnings" class="section level2">
<h2>Rejection sampling warnings</h2>
<p>Sometimes when running <code>smcfcs</code> you may receive warnings
that the rejection sampling that <code>smcfcs</code> uses has failed to
draw from the required distribution on a couple of occasions. Upon
receiving this warning, it is generally good idea to re-run
<code>smcfcs</code>, specifying a value for <code>rjlimit</code> which
is larger than the default, until the warning is no longer issued.
Having said that, when only a small number of warnings are issued, it
may be fine to ignore the warnings, especially when the dataset is
large.</p>
</div>
<div id="assessing-convergence" class="section level2">
<h2>Assessing convergence</h2>
<p>Like standard chained equations or FCS imputation, the SMC-FCS
algorithm must be run for a sufficient number of iterations for the
process to converge to its stationary distribution. The default number
of iterations used is 10, but this may not be sufficient in any given
dataset and model specification To assess convergence, the object
returned by <code>smcfcs</code> includes an object called
<code>smCoefIter</code>. This matrix contains the parameter estimates of
the substantive model, and is indexed by imputation number, parameter
number, and iteration number. To assess convergence, one can call smcfcs
with <code>m=1</code> and <code>numit</code> suitably chosen
(e.g. <code>numit=100</code>). The values in the resulting smCoefIter
matrix can then be plotted to assess convergence. To illustrate, we
re-run the imputation model used previously with the example data, but
asking for only <code>m=1</code> imputation to be generated, and with
100 iterations.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># impute once with a larger number of iterations than the default 10</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>imps <span class="ot">&lt;-</span> <span class="fu">smcfcs</span>(ex_linquad, <span class="at">smtype=</span><span class="st">&quot;lm&quot;</span>, <span class="at">smformula=</span><span class="st">&quot;y~z+x+xsq&quot;</span>,<span class="at">method=</span><span class="fu">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;x^2&quot;</span>,<span class="st">&quot;&quot;</span>),<span class="at">predictorMatrix=</span>predMatrix,<span class="at">m=</span><span class="dv">1</span>,<span class="at">numit=</span><span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] &quot;Outcome variable(s): y&quot;
## [1] &quot;Passive variables: xsq&quot;
## [1] &quot;Partially obs. variables: x&quot;
## [1] &quot;Fully obs. substantive model variables: z&quot;
## [1] &quot;Imputation  1&quot;
## [1] &quot;Imputing:  x  using  z,v  plus outcome&quot;</code></pre>
<pre><code>## Warning in smcfcs.core(originaldata, smtype, smformula, method,
## predictorMatrix, : Rejection sampling failed 1 times (across all variables,
## iterations, and imputations). You may want to increase the rejection sampling
## limit.</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot estimates of the fourth parameter of the substantive model against iteration number</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(imps<span class="sc">$</span>smCoefIter[<span class="dv">1</span>,<span class="dv">4</span>,])</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>The plot shows that the process appears to converge rapidly, such
that the default choice of <code>numit=10</code> is probably fine here.
Of course we should also examine the corresponding plots for the other
parameters of the substantive model, since convergence may require more
than 10 iterations for some of these.</p>
<h2 id="references">
References
</h3>
<p>Bartlett JW, Seaman SR, White IR, Carpenter JR. Multiple imputation
of covariates by fully conditional specification: accommodating the
substantive model.
<a href="https://doi.org/10.1177/0962280214521348">Statistical Methods
in Medical Research</a>, 2015; 24(4):462-487</p>
<p>van Buuren S, Groothuis-Oudshoorn K. mice: Multivariate Imputation by
Chained Equations in R.
<a href="https://doi.org/10.18637/jss.v045.i03">Journal of Statistical
Software</a>, 2011; 45(3)</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
